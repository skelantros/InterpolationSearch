import scala.annotation.tailrec
import Metric.MetricOps

object InterpolationSearch {
  // Реализация алгоритма интерполяционного поиска, обобщенная для всех типов с введенной "метрикой"
  // Функция возвращает индекс элемента в массиве, если он есть, и число итераций
  def interpolateSearch[T : Metric](arr: Array[T])(x: T): (Option[Int], Int) = {
    // Вычисление предположительного индекса элемента со значением X на отрезке [arr(l), arr(r)]
    // Здесь x |-| y - "разность" между элементами x и y (см. описание интерфейса Metric)
    def nextIdx(l: Int, r: Int): Int =
      (l + 1.0 * (x |-| arr(l)) / (arr(r) |-| arr(l)) * (r - l)).toInt

    // Реализация алгоритма в рекурсивном варианте
    // Алгоритм реализован с помощью хвостовой рекурсии, поэтому при компиляции рекурсивная функция преобразуется в цикл
    @tailrec
    def go(curL: Int, curR: Int, iters: Int): (Option[Int], Int) = {
      // Основная часть алгоритма выполняется, если левый индекс не меньше правого,
      // и искомое значение лежит в части массива, которая ограничивается индексами
      if(curL <= curR && arr(curL) <= x && arr(curR) >= x) {
        val next = nextIdx(curL, curR)
        val nVal = arr(next)

        // Если алгоритм "попал" и нашел искомый элемент, возвращается найденный индекс
        if(nVal == x) (Some(next), iters)
        // Если выбранное алгоритмом значение меньше искомого, найденный индекс принимается за левую границу
        else if(nVal < x) go(next + 1, curR, iters + 1)
        // Если выбранное алгоритмом значение больше искомого, найденный индекс принимается за правую границу
        else go(curL, next - 1, iters + 1)
      }
      // Если условия основной части не выполняются, это означает, что искомого значения в массиве нет
      else (None, iters)
    }

    // Вызов рекурсивной функции с исходными значениями (левая и правая граница соответствуют границам массива)
    go(0, arr.length - 1, 1)
  }
}
